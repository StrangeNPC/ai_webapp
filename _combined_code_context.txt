--- File: googleAI.txt ---
Okay, this is a significant project, especially for someone new to web development and cloud deployment. I will break this down into manageable, step-by-step instructions. We will build a solid foundation that meets the core requirements.

**Important Notes Before We Start:**

1.  **Patience is Key:** This involves multiple technologies (React, Python, AWS, OpenAI). There will be hurdles. Take your time, read error messages carefully, and don't get discouraged.
2.  **Costs:** AWS services (Elastic Beanstalk, S3, potentially API Gateway/Lambda if you deviate) and the OpenAI API have costs associated with them. AWS has a free tier, but be mindful of usage. OpenAI API usage is pay-as-you-go after any initial free credits expire. **Remember to shut down AWS resources after you are done testing if you don't need them running to avoid unexpected bills.**
3.  **Security:** We will handle API keys using environment variables, which is good practice. Never commit API keys directly into your code on GitHub.
4.  **Simplicity Over Complexity:** Given your background, we'll stick to the simplest implementation that meets the requirements. We'll use React with plain CSS, Python with FastAPI, and deploy the backend to Elastic Beanstalk. The frontend will be deployed to AWS S3.
5.  **Professional Look (with constraints):** Since you requested no UI libraries (Tailwind/Material UI), achieving a "professional" look relies heavily on clean layout, spacing, typography, and color choices using plain CSS. It will be simpler than sites using libraries but can still be clean.

**Let's Get Started!**

---

**Phase 0: Prerequisites**

You need the following installed and set up:

1.  **Node.js and npm:** For the React frontend. Download from [nodejs.org](https://nodejs.org/). npm comes bundled with Node.js. Verify installation by opening your terminal or command prompt and running `node -v` and `npm -v`.
2.  **Python:** For the backend. Download from [python.org](https://python.org/) (Version 3.8 or higher recommended). Make sure Python is added to your system's PATH during installation. Verify by running `python --version` or `python3 --version`.
3.  **pip:** Python's package installer. Usually comes with Python. Verify with `pip --version` or `pip3 --version`.
4.  **Git:** For version control and managing your code. Download from [git-scm.com](https://git-scm.com/).
5.  **AWS Account:** Sign up at [aws.amazon.com](https://aws.amazon.com/). You'll need a credit card for verification, even for the free tier.
6.  **AWS CLI:** AWS Command Line Interface. Follow the installation guide for your OS: [AWS CLI Installation Guide](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html). After installation, configure it by running `aws configure` in your terminal. You'll need AWS Access Keys (Access Key ID and Secret Access Key).
    *   **Creating AWS Access Keys:** Go to the AWS Console -> IAM (Identity and Access Management) -> Users -> Your User -> Security credentials -> Create access key. Choose "Command Line Interface (CLI)" as the use case. **Save the Access Key ID and Secret Access Key securely â€“ you won't see the secret key again.** Enter these when prompted by `aws configure`, along with your preferred default region (e.g., `us-east-1`, `eu-west-1`). Choose a default output format (like `json`).
7.  **OpenAI API Key:** Sign up at [openai.com](https://openai.com/) and navigate to the API section to get your API key. Keep this key safe!
8.  **Code Editor:** Visual Studio Code (VS Code) is highly recommended ([code.visualstudio.com](https://code.visualstudio.com/)).
9.  **EB CLI:** Elastic Beanstalk Command Line Interface. Install using pip: `pip install awsebcli --upgrade`. Verify with `eb --version`.

---

**Phase 1: Project Setup**

1.  **Create Project Folder:** Open your terminal or command prompt and create a main directory for your project.
    ```bash
    mkdir ai-news-analyzer
    cd ai-news-analyzer
    ```
2.  **Initialize Git:**
    ```bash
    git init
    ```
3.  **Create Backend and Frontend Folders:**
    ```bash
    mkdir backend
    mkdir frontend
    ```
4.  **Create `.gitignore`:** Create a file named `.gitignore` in the main `ai-news-analyzer` directory. This tells Git which files/folders to ignore (like sensitive keys or large dependencies). Add the following:

    ```gitignore
    # General
    .DS_Store
    *.log
    *.pot
    *.pyc
    __pycache__/

    # Python Virtual Environment
    backend/venv/
    backend/.env

    # Node Modules
    frontend/node_modules/
    frontend/build/
    frontend/.env*
    frontend/npm-debug.log*
    frontend/yarn-debug.log*
    frontend/yarn-error.log*

    # AWS Elastic Beanstalk
    .elasticbeanstalk/
    ```

---

**Phase 2: Backend Development (Python/FastAPI)**

1.  **Navigate to Backend Folder:**
    ```bash
    cd backend
    ```
2.  **Create Virtual Environment:** (Good practice to isolate project dependencies)
    ```bash
    python -m venv venv
    # On Windows:
    venv\Scripts\activate
    # On macOS/Linux:
    source venv/bin/activate
    ```
    Your terminal prompt should now show `(venv)` at the beginning.

3.  **Install Dependencies:**
    ```bash
    pip install fastapi uvicorn python-dotenv openai python-multipart python-docx "uvicorn[standard]"
    ```
    *   `fastapi`: The web framework.
    *   `uvicorn`: The ASGI server to run FastAPI. `[standard]` includes performance extras.
    *   `python-dotenv`: To load environment variables from a `.env` file for local development.
    *   `openai`: The official OpenAI Python client library.
    *   `python-multipart`: Needed for FastAPI to handle file uploads.
    *   `python-docx`: To read text from `.docx` files.

4.  **Create `.env` File:** Create a file named `.env` (note the leading dot) *inside the `backend` folder*. Add your OpenAI API key:
    ```env
    # backend/.env
    OPENAI_API_KEY=your_openai_api_key_here
    ```
    **Replace `your_openai_api_key_here` with your actual key. Remember this file is in `.gitignore` and should NOT be committed to GitHub.**

5.  **Create `main.py`:** This is your main application file. Create `main.py` inside the `backend` folder.

    ```python
    # backend/main.py
    import os
    import io
    from dotenv import load_dotenv
    from fastapi import FastAPI, File, UploadFile, Form, HTTPException, Request
    from fastapi.middleware.cors import CORSMiddleware
    from pydantic import BaseModel
    import openai
    import docx # For reading .docx files

    # Load environment variables from .env file (especially for local development)
    load_dotenv()

    # --- Configuration ---
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    if not OPENAI_API_KEY:
        print("Error: OPENAI_API_KEY not found in environment variables.")
        # In a real app, you might raise an exception or handle this more gracefully
        # For EB deployment, we'll set this via EB environment properties.
        # exit(1) # Exit if running locally without a key

    if OPENAI_API_KEY:
         openai.api_key = OPENAI_API_KEY
    else:
        print("Warning: OpenAI API Key not configured. API calls will fail.")

    # --- FastAPI App Initialization ---
    app = FastAPI(title="AI News Analyzer API")

    # --- CORS Middleware ---
    # This allows your frontend (running on a different domain/port)
    # to communicate with your backend.
    # IMPORTANT: Adjust origins as needed for production. Using ["*"] is
    # permissive and okay for this assessment, but for a real production
    # app, list specific frontend URLs.
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"], # Allows all origins
        allow_credentials=True,
        allow_methods=["*"], # Allows all methods (GET, POST, etc.)
        allow_headers=["*"], # Allows all headers
    )

    # --- Helper Functions ---
    def get_openai_completion(prompt_text, model="gpt-3.5-turbo"):
        """Calls the OpenAI Chat Completion API."""
        if not OPENAI_API_KEY:
             raise HTTPException(status_code=500, detail="OpenAI API key not configured on the server.")
        try:
            response = openai.chat.completions.create(
                model=model,
                messages=[
                    {"role": "system", "content": "You are a helpful assistant."},
                    {"role": "user", "content": prompt_text}
                ]
            )
            # Check if response structure is as expected
            if response.choices and len(response.choices) > 0:
                message_content = response.choices[0].message.content
                if message_content:
                    return message_content.strip()
            return "Error: Could not extract content from OpenAI response." # Or handle more gracefully

        except openai.APIError as e:
             print(f"OpenAI API returned an API Error: {e}")
             raise HTTPException(status_code=500, detail=f"OpenAI API Error: {e}")
        except openai.APIConnectionError as e:
            print(f"Failed to connect to OpenAI API: {e}")
            raise HTTPException(status_code=503, detail=f"OpenAI Connection Error: {e}")
        except openai.RateLimitError as e:
            print(f"OpenAI API request exceeded rate limit: {e}")
            raise HTTPException(status_code=429, detail=f"OpenAI Rate Limit Exceeded: {e}")
        except Exception as e:
            print(f"An unexpected error occurred during OpenAI call: {e}")
            raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")


    def summarize_text(text):
        """Generates a summary using OpenAI."""
        prompt = f"""
        Please summarize the following news article in 2-4 concise sentences:

        \"\"\"
        {text}
        \"\"\"

        Summary:
        """
        return get_openai_completion(prompt)

    def extract_nationalities(text):
        """Extracts nationalities/countries using OpenAI."""
        prompt = f"""
        Analyze the following news article and list all mentioned nationalities, countries, or peoples.
        If a country is mentioned (e.g., France, Japan), list the country name.
        If a nationality or people is mentioned (e.g., French, Japanese, Canadians), list the nationality/people.
        Provide the output as a comma-separated list. If none are found, respond with "None".

        Article:
        \"\"\"
        {text}
        \"\"\"

        Nationalities/Countries mentioned (comma-separated):
        """
        result = get_openai_completion(prompt)
        if result and result.lower() != "none":
            # Split by comma and strip whitespace from each item
            return [item.strip() for item in result.split(',') if item.strip()]
        else:
            return [] # Return an empty list if none found or error


    def read_docx(file_content: bytes) -> str:
        """Reads text content from a .docx file's bytes."""
        try:
            # Use BytesIO to treat the bytes content like a file
            doc_stream = io.BytesIO(file_content)
            doc = docx.Document(doc_stream)
            full_text = []
            for para in doc.paragraphs:
                full_text.append(para.text)
            return '\n'.join(full_text)
        except Exception as e:
            print(f"Error reading docx file: {e}")
            # Consider if this should raise HTTPException or return an error indicator
            raise HTTPException(status_code=400, detail=f"Could not read the .docx file. Error: {e}")


    # --- Pydantic Models (for request validation, though not strictly needed for Form/File) ---
    # We'll rely on FastAPI's Form and File parameters directly

    # --- API Endpoints ---
    @app.get("/")
    async def root():
        return {"message": "Welcome to the AI News Analyzer API"}

    @app.post("/analyze")
    async def analyze_article(
        text_content: str = Form(None), # Text content from form
        file_upload: UploadFile = File(None) # File upload
    ):
        """
        Analyzes news article text (either provided directly or via file upload)
        to generate a summary and extract nationalities.
        Accepts either 'text_content' (string) or 'file_upload' (.txt or .docx).
        """
        article_text = ""
        filename = None

        # --- Input Validation and Reading ---
        if file_upload:
            filename = file_upload.filename
            print(f"Received file: {filename}")
            # Read file content
            contents = await file_upload.read()
            # Check file type based on filename extension
            if filename.lower().endswith(".txt"):
                try:
                    article_text = contents.decode("utf-8")
                except UnicodeDecodeError:
                    # Try another common encoding if UTF-8 fails
                    try:
                         article_text = contents.decode("latin-1")
                    except Exception as e:
                        raise HTTPException(status_code=400, detail=f"Could not decode .txt file. Ensure it's UTF-8 or Latin-1 encoded. Error: {e}")
            elif filename.lower().endswith(".docx"):
                 try:
                    article_text = read_docx(contents)
                 except HTTPException as e:
                    # Re-raise the exception from read_docx if it failed validation/reading
                    raise e
                 except Exception as e:
                    # Catch any other unexpected errors during docx reading
                    print(f"Unexpected error reading .docx: {e}")
                    raise HTTPException(status_code=500, detail=f"Server error processing .docx file: {e}")
            else:
                raise HTTPException(status_code=400, detail="Invalid file type. Please upload a .txt or .docx file.")

        elif text_content:
            print("Received text content.")
            article_text = text_content
        else:
            raise HTTPException(status_code=400, detail="No input provided. Please provide text_content or upload a file.")

        if not article_text.strip():
             raise HTTPException(status_code=400, detail="Input text is empty.")

        # Limit input size to prevent excessive costs/processing time (e.g., 10000 characters)
        MAX_LENGTH = 15000
        if len(article_text) > MAX_LENGTH:
             raise HTTPException(status_code=413, # Payload Too Large
                                 detail=f"Input text is too long (>{MAX_LENGTH} chars). Please provide shorter text.")


        # --- Processing ---
        print("Input text length:", len(article_text))
        print("Calling OpenAI for summary...")
        summary = summarize_text(article_text)
        print("Calling OpenAI for nationalities...")
        nationalities = extract_nationalities(article_text)
        print("Analysis complete.")

        # --- Return Response ---
        return {
            "summary": summary,
            "nationalities": nationalities
        }

    # --- Optional: Add Exception Handlers for better error responses ---
    @app.exception_handler(HTTPException)
    async def http_exception_handler(request: Request, exc: HTTPException):
        return JSONResponse(
            status_code=exc.status_code,
            content={"detail": exc.detail},
        )

    @app.exception_handler(Exception)
    async def generic_exception_handler(request: Request, exc: Exception):
        # Log the exception for debugging
        print(f"An unexpected error occurred: {exc}")
        # Return a generic server error response
        return JSONResponse(
            status_code=500,
            content={"detail": "An internal server error occurred."},
        )

    # --- Add this at the end for local running ---
    # Note: For Elastic Beanstalk, Uvicorn will be run differently based on EB's config.
    # This block allows running locally using `python main.py`
    if __name__ == "__main__":
        import uvicorn
        # Run on 0.0.0.0 to make it accessible from other devices on your network
        # (useful if testing frontend from a different machine/VM)
        # Use port 8000, a common default for local dev servers
        uvicorn.run(app, host="0.0.0.0", port=8000)

    ```

6.  **Create `requirements.txt`:** Elastic Beanstalk needs this file to know which Python packages to install.
    ```bash
    pip freeze > requirements.txt
    ```
    *(Make sure your virtual environment is active when you run this)*. Check the generated `requirements.txt` file. It should list `fastapi`, `uvicorn`, `python-dotenv`, `openai`, `python-multipart`, `python-docx`, etc., along with their versions.

7.  **Local Testing:**
    *   Make sure your `(venv)` is active.
    *   Run the server: `uvicorn main:app --reload --host 0.0.0.0 --port 8000`
        *   `main:app`: Tells uvicorn to find the `app` object inside the `main.py` file.
        *   `--reload`: Automatically restarts the server when code changes (great for development).
    *   Open your web browser to `http://127.0.0.1:8000`. You should see `{"message":"Welcome to the AI News Analyzer API"}`.
    *   Go to `http://127.0.0.1:8000/docs`. FastAPI provides automatic interactive API documentation (Swagger UI). You can test your `/analyze` endpoint here by expanding it, clicking "Try it out", entering text or uploading a file, and clicking "Execute". Check your terminal running uvicorn for `print` statements and any errors.

8.  **Deactivate Virtual Environment (for now):**
    ```bash
    deactivate
    ```

---

**Phase 3: Backend Deployment (AWS Elastic Beanstalk)**

This is often the trickiest part for beginners. Follow carefully.

1.  **Navigate to Backend Folder:** Make sure you are in the `ai-news-analyzer/backend` directory in your terminal.
2.  **Initialize Elastic Beanstalk:**
    ```bash
    eb init -p python-3.9 -r YOUR_AWS_REGION ai-news-analyzer-backend
    ```
    *   Replace `python-3.9` with the Python version you intend to use (EB supports several, e.g., 3.8, 3.9, 3.11). Choose one compatible with your code and dependencies.
    *   Replace `YOUR_AWS_REGION` with the AWS region code you configured with the AWS CLI (e.g., `us-east-1`, `eu-west-2`).
    *   `ai-news-analyzer-backend` is the name for your EB Application.
    *   It might ask if you want to use CodeCommit (say `n` unless you want to).
    *   It might ask for SSH key setup - you can skip this for now by saying `n` or pressing Enter if it offers a default `(default is n)`.

3.  **Configure Procfile:** Elastic Beanstalk needs to know how to start your web application. Create a file named `Procfile` (exactly that name, capital P, no extension) in the `backend` directory:
    ```Procfile
    # backend/Procfile
    web: uvicorn main:app --host 0.0.0.0 --port 8080
    ```
    *   **Important:** EB typically forwards external traffic from port 80 to port 8080 on your instance. Uvicorn needs to listen on `0.0.0.0` (all available network interfaces) and port `8080`.

4.  **(Optional but Recommended) `.ebextensions` for Configuration:** This is the standard way to configure environment variables and other settings on EB instances *without* hardcoding them or manually setting them in the console every time.
    *   Create a folder named `.ebextensions` (note the leading dot) inside the `backend` folder.
    *   Inside `.ebextensions`, create a file named `01_env_vars.config` (the name matters, `.config` extension is key).
    *   Add the following content:

    ```yaml
    # backend/.ebextensions/01_env_vars.config
    option_settings:
      aws:elasticbeanstalk:application:environment:
        PYTHONPATH: "/var/app/current" # Helps EB find your main.py
        OPENAI_API_KEY: "YOUR_OPENAI_API_KEY_HERE_FOR_DEPLOYMENT" # Replace this!
        # Add any other environment variables needed here
    ```
    *   **VERY IMPORTANT:** Replace `YOUR_OPENAI_API_KEY_HERE_FOR_DEPLOYMENT` with your *actual* OpenAI API key. **Yes, this file gets committed to Git.** This is a standard EB practice. To make it *more* secure, you *could* avoid putting the key here and instead set it manually in the EB Console (Configuration -> Software -> Environment properties) *after* the environment is created. For this assessment, putting it here is acceptable *as long as your GitHub repo is private*. If the repo is public, **DO NOT COMMIT YOUR KEY HERE**. Set it manually in the AWS console instead.

5.  **Create the Elastic Beanstalk Environment:**
    ```bash
    eb create ai-news-analyzer-env
    ```
    *   `ai-news-analyzer-env` is the name for your environment (the running instance(s) of your application).
    *   This command will:
        *   Zip up your application code (everything in the `backend` folder, respecting `.gitignore`).
        *   Upload the zip file to an S3 bucket created by EB.
        *   Provision the necessary AWS resources (EC2 instance, security group, load balancer, etc.).
        *   Deploy your code to the instance(s).
        *   Apply configurations from `.ebextensions`.
    *   **This step takes several minutes (5-15 mins).** Watch the output in your terminal. It will show the progress of events.
    *   If successful, it will output a URL (CNAME) ending in `elasticbeanstalk.com`. This is your backend API URL! Example: `http://ai-news-analyzer-env.eba-xxxxxxxx.us-east-1.elasticbeanstalk.com`

6.  **Verify Deployment:**
    *   Open the URL provided by `eb create` in your browser. You should see `{"message":"Welcome to the AI News Analyzer API"}`.
    *   You can also check the health and logs in the AWS Elastic Beanstalk console.

7.  **Updating Your Application:**
    *   After making changes to your backend code (`main.py`, `requirements.txt`, etc.):
    *   Make sure your changes are saved.
    *   Run: `eb deploy`
    *   This will package and deploy the new version.

8.  **Troubleshooting EB:**
    *   `eb status`: Check the environment health.
    *   `eb logs`: Fetch logs from the EC2 instance(s). Crucial for debugging deployment issues.
    *   `eb health`: View detailed health information.
    *   `eb open`: Opens the application URL in your browser.
    *   Check the Elastic Beanstalk console in AWS for events and logs. Common issues involve incorrect `Procfile`, missing dependencies in `requirements.txt`, errors in your Python code, or IAM permissions.

---

**Phase 4: Frontend Development (React + Plain CSS)**

1.  **Navigate to Frontend Folder:**
    ```bash
    cd ../frontend
    # (Make sure you are in ai-news-analyzer/frontend)
    ```

2.  **Create React App:**
    ```bash
    npx create-react-app .
    # Use '.' to create the app in the current 'frontend' directory
    ```
    This will create a standard React project structure.

3.  **Clean Up (Optional):** You can remove some default files you won't use:
    *   `src/App.test.js`
    *   `src/logo.svg`
    *   `src/reportWebVitals.js`
    *   `src/setupTests.js`
    *   Update `src/index.js` to remove references to `reportWebVitals`.
    *   Update `src/App.js` to remove the logo import and default content.

4.  **Write `App.js` (Main Component):** Replace the content of `src/App.js`:

    ```javascript
    // src/App.js
    import React, { useState, useCallback } from 'react';
    import './App.css'; // We'll create this for styling

    function App() {
      const [inputText, setInputText] = useState('');
      const [selectedFile, setSelectedFile] = useState(null);
      const [summary, setSummary] = useState('');
      const [nationalities, setNationalities] = useState([]);
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState('');

      // --- IMPORTANT: Replace with your DEPLOYED backend URL ---
      // Get this URL from the 'eb create' command output or the EB console
      const BACKEND_API_URL = 'http://YOUR_ELASTICBEANSTALK_ENVIRONMENT_URL/analyze';
      // Example: const BACKEND_API_URL = 'http://ai-news-analyzer-env.eba-rmqepxud.us-east-1.elasticbeanstalk.com/analyze';
      // For local testing (if backend runs on port 8000):
      // const BACKEND_API_URL = 'http://localhost:8000/analyze';

      const handleTextChange = (event) => {
        setInputText(event.target.value);
        // If user types text, clear any selected file
        if (event.target.value) {
            setSelectedFile(null);
        }
      };

      const handleFileChange = (event) => {
        const file = event.target.files[0];
        if (file) {
           // Basic validation for allowed types (client-side)
           const allowedTypes = ['text/plain', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
           if (allowedTypes.includes(file.type)) {
                setSelectedFile(file);
                setInputText(''); // Clear text input if file is selected
                setError(''); // Clear previous errors
           } else {
                setError('Invalid file type. Please upload a .txt or .docx file.');
                setSelectedFile(null); // Reset file selection
                event.target.value = null; // Reset the file input visually
           }
        }
      };

      const handleSubmit = useCallback(async (event) => {
        event.preventDefault(); // Prevent default form submission
        setIsLoading(true);
        setError('');
        setSummary('');
        setNationalities([]);

        // Ensure backend URL is set
        if (!BACKEND_API_URL || BACKEND_API_URL.includes('YOUR_ELASTICBEANSTALK_ENVIRONMENT_URL')) {
             setError('Backend API URL is not configured in App.js. Please update it.');
             setIsLoading(false);
             return;
        }


        // Use FormData to send either text or file
        const formData = new FormData();
        if (selectedFile) {
          formData.append('file_upload', selectedFile);
        } else if (inputText.trim()) {
          formData.append('text_content', inputText);
        } else {
          setError('Please enter text or upload a file.');
          setIsLoading(false);
          return;
        }

        try {
          const response = await fetch(BACKEND_API_URL, {
            method: 'POST',
            body: formData, // Send FormData directly, browser sets Content-Type correctly
            // No need to set Content-Type header manually when using FormData with fetch
          });

          const data = await response.json(); // Always try to parse JSON

          if (!response.ok) {
             // Use error detail from backend if available, otherwise use status text
             const errorDetail = data.detail || `Request failed with status ${response.status}`;
             throw new Error(errorDetail);
          }

          // Assuming backend returns { summary: "...", nationalities: ["...", "..."] } on success
          setSummary(data.summary || 'No summary generated.');
          setNationalities(data.nationalities || []);

        } catch (err) {
          console.error("API call failed:", err);
          setError(`Error: ${err.message || 'Failed to fetch analysis.'}. Check console for details.`);
          // Clear results on error
          setSummary('');
          setNationalities([]);
        } finally {
          setIsLoading(false);
        }
      }, [inputText, selectedFile, BACKEND_API_URL]); // Dependencies for useCallback

      return (
        <div className="App">
          <header className="App-header">
            <h1>AI News Article Analyzer</h1>
            <p>Enter article text below or upload a .txt/.docx file.</p>
          </header>

          <main className="App-main">
            <form onSubmit={handleSubmit} className="Input-form">
              <div className="Input-section">
                <label htmlFor="text-input">Enter News Article Text:</label>
                <textarea
                  id="text-input"
                  value={inputText}
                  onChange={handleTextChange}
                  placeholder="Paste your news article here..."
                  rows="10"
                  disabled={isLoading || !!selectedFile} // Disable if loading or file selected
                />
              </div>

              <div className="Input-or">OR</div>

              <div className="Input-section">
                <label htmlFor="file-input">Upload Article File (.txt or .docx):</label>
                <input
                  id="file-input"
                  type="file"
                  accept=".txt, .docx, text/plain, application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                  onChange={handleFileChange}
                  disabled={isLoading || !!inputText} // Disable if loading or text entered
                />
                 {selectedFile && <p className="File-info">Selected file: {selectedFile.name}</p>}
              </div>

              <button type="submit" disabled={isLoading || (!inputText && !selectedFile)}>
                {isLoading ? 'Analyzing...' : 'Analyze Article'}
              </button>
            </form>

            {isLoading && <div className="Loading-spinner"></div>}

            {error && <div className="Error-message">{error}</div>}

            {!isLoading && (summary || nationalities.length > 0) && (
              <div className="Results-section">
                {summary && (
                  <div className="Result-item">
                    <h2>Summary</h2>
                    <p>{summary}</p>
                  </div>
                )}

                {nationalities.length > 0 && (
                  <div className="Result-item">
                    <h2>Mentioned Nationalities/Countries</h2>
                    <ul>
                      {nationalities.map((nat, index) => (
                        <li key={index}>{nat}</li>
                      ))}
                    </ul>
                  </div>
                )}
                 {!summary && nationalities.length === 0 && !error && <p>Analysis complete, but no summary or nationalities were extracted.</p>}
              </div>
            )}
          </main>

          <footer className="App-footer">
            <p>Assessment Project</p>
          </footer>
        </div>
      );
    }

    export default App;

    ```

5.  **Create `App.css` for Styling:** Create a file `src/App.css`. Add some basic styles. You can expand on this significantly to make it look more professional.

    ```css
    /* src/App.css */
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
        'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
        sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      background-color: #f4f7f6; /* Light background */
      color: #333; /* Default text color */
    }

    .App {
      max-width: 800px; /* Limit content width */
      margin: 0 auto; /* Center the app */
      padding: 20px;
    }

    .App-header {
      background-color: #282c34; /* Dark header */
      padding: 20px;
      color: white;
      text-align: center;
      border-radius: 8px 8px 0 0; /* Rounded top corners */
      margin-bottom: 20px;
    }

    .App-header h1 {
        margin: 0 0 10px 0;
    }
    .App-header p {
        margin: 0;
        font-size: 0.9em;
        color: #ccc;
    }

    .App-main {
      background-color: #ffffff; /* White background for main content */
      padding: 30px;
      border-radius: 0 0 8px 8px; /* Rounded bottom corners */
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    }

    .Input-form {
      display: flex;
      flex-direction: column;
      gap: 20px; /* Space between form elements */
    }

    .Input-section {
      display: flex;
      flex-direction: column;
    }

    .Input-section label {
      margin-bottom: 8px;
      font-weight: bold;
      color: #555;
    }

    .Input-section textarea {
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1rem;
      min-height: 150px; /* Make textarea reasonably large */
      resize: vertical; /* Allow vertical resizing */
    }
     .Input-section textarea:disabled {
        background-color: #e9ecef; /* Indicate disabled state */
        cursor: not-allowed;
     }

    .Input-section input[type="file"] {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 0.9rem;
    }
    .Input-section input[type="file"]:disabled {
        background-color: #e9ecef;
        cursor: not-allowed;
    }

    .Input-or {
      text-align: center;
      font-weight: bold;
      color: #888;
      margin: 10px 0;
    }

    .File-info {
        font-size: 0.9em;
        color: #666;
        margin-top: 5px;
    }

    button[type="submit"] {
      padding: 12px 20px;
      background-color: #007bff; /* Primary button color */
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
      transition: background-color 0.2s ease;
      margin-top: 15px; /* Space above button */
    }

    button[type="submit"]:hover:not(:disabled) {
      background-color: #0056b3; /* Darker blue on hover */
    }

    button[type="submit"]:disabled {
      background-color: #cccccc; /* Grey out when disabled */
      cursor: not-allowed;
    }

    .Loading-spinner {
      border: 4px solid #f3f3f3; /* Light grey */
      border-top: 4px solid #3498db; /* Blue */
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 30px auto; /* Center the spinner */
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .Error-message {
      color: #dc3545; /* Red for errors */
      background-color: #f8d7da; /* Light red background */
      border: 1px solid #f5c6cb;
      padding: 15px;
      border-radius: 4px;
      margin-top: 20px;
      text-align: center;
    }

    .Results-section {
      margin-top: 30px;
      border-top: 1px solid #eee; /* Separator line */
      padding-top: 20px;
    }

    .Result-item {
      margin-bottom: 25px;
    }

    .Result-item h2 {
      color: #0056b3; /* Match button hover color */
      margin-bottom: 10px;
      border-bottom: 2px solid #eee; /* Underline heading */
      padding-bottom: 5px;
    }

    .Result-item p {
      line-height: 1.6;
      white-space: pre-wrap; /* Respect newlines in summary */
    }

    .Result-item ul {
      list-style: disc;
      padding-left: 20px;
    }
    .Result-item li {
        margin-bottom: 5px;
    }

    .App-footer {
      margin-top: 40px;
      text-align: center;
      font-size: 0.8em;
      color: #888;
      padding-top: 20px;
      border-top: 1px solid #eee;
    }
    ```

6.  **Modify `src/index.js`:** Remove `reportWebVitals`.

    ```javascript
    // src/index.js
    import React from 'react';
    import ReactDOM from 'react-dom/client';
    import './index.css'; // Keep global styles if any
    import App from './App';
    // Remove or comment out the next line:
    // import reportWebVitals from './reportWebVitals';

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <React.StrictMode>
        <App />
      </React.StrictMode>
    );

    // Remove or comment out the function call:
    // If you want to start measuring performance in your app, pass a function
    // to log results (for example: reportWebVitals(console.log))
    // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
    // reportWebVitals();
    ```

7.  **Local Testing:**
    *   Make sure your backend is running (either locally with `uvicorn` or the deployed EB version).
    *   **Crucially, update the `BACKEND_API_URL` constant in `src/App.js` to point to your backend.** If testing locally, use `http://localhost:8000/analyze`. If testing against deployed EB, use the `elasticbeanstalk.com` URL.
    *   Start the React development server:
        ```bash
        npm start
        ```
    *   This should automatically open `http://localhost:3000` in your browser.
    *   Test the form: enter text, upload files (`.txt`, `.docx`), click submit. Check if the loading spinner appears, and if results or errors are displayed correctly. Check the browser's developer console (F12) for any errors.

---

**Phase 5: Frontend Deployment (AWS S3 Static Website Hosting)**

We'll deploy the *built* frontend code (static HTML, CSS, JS) to an S3 bucket.

1.  **Build the React App:**
    *   Make sure you are in the `ai-news-analyzer/frontend` directory.
    *   **Important:** Ensure the `BACKEND_API_URL` in `src/App.js` is set to your *deployed Elastic Beanstalk URL*.
    *   Run the build command:
        ```bash
        npm run build
        ```
    *   This creates a `build` folder containing the optimized static files for production.

2.  **Create S3 Bucket:**
    *   Go to the AWS Management Console -> S3.
    *   Click "Create bucket".
    *   **Bucket name:** Must be globally unique (e.g., `yourname-ai-news-analyzer-frontend`). Use only lowercase letters, numbers, and hyphens.
    *   **Region:** Choose the same region as your backend or one geographically close to your users.
    *   **Object Ownership:** Select "ACLs enabled" and "Bucket owner preferred". (This might differ slightly based on AWS updates, aim for enabling ACLs if presented).
    *   **Block Public Access settings:** *Uncheck* "Block *all* public access". You need to allow public reads for a website. Check the box acknowledging that this will make the bucket public. **Be careful with public buckets â€“ only website assets should be public.**
    *   Leave other settings as default and click "Create bucket".

3.  **Enable Static Website Hosting:**
    *   Go into the bucket you just created.
    *   Click the "Properties" tab.
    *   Scroll down to "Static website hosting" and click "Edit".
    *   Select "Enable".
    *   **Hosting type:** Choose "Host a static website".
    *   **Index document:** Enter `index.html`.
    *   **Error document (optional):** You can also enter `index.html` or a custom error page if you have one.
    *   Click "Save changes".
    *   Note the **Bucket website endpoint** URL provided in this section. It will look like `http://your-bucket-name.s3-website-your-region.amazonaws.com`.

4.  **Set Bucket Policy for Public Access:**
    *   Go to the "Permissions" tab of your bucket.
    *   Scroll down to "Bucket policy" and click "Edit".
    *   Paste the following policy, **replacing `YOUR_BUCKET_NAME` with your actual bucket name**:

    ```json
    {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Sid": "PublicReadGetObject",
                "Effect": "Allow",
                "Principal": "*",
                "Action": "s3:GetObject",
                "Resource": "arn:aws:s3:::YOUR_BUCKET_NAME/*"
            }
        ]
    }
    ```
    *   Click "Save changes". You should see a "Publicly accessible" tag near your bucket name.

5.  **Upload Build Files:**
    *   Go back to the "Objects" tab of your bucket.
    *   Open the `frontend/build` folder on your computer.
    *   Drag and drop **all the contents** of the `build` folder (including the `static` folder, `index.html`, `manifest.json`, etc.) directly into the S3 bucket console window. *Do not upload the `build` folder itself, just its contents.*
    *   Click "Upload". Wait for it to complete.

6.  **Test the Live Frontend:**
    *   Open the **Bucket website endpoint** URL (from step 3) in your browser.
    *   Your React application should load. Test it thoroughly by submitting text and files.

---

**Phase 6: GitHub Repository and README**

1.  **Commit Your Code:**
    *   Make sure you are in the main `ai-news-analyzer` directory.
    *   Check status: `git status` (ensure `.env`, `node_modules`, `venv`, `.elasticbeanstalk` are ignored).
    *   Add files: `git add .`
    *   Commit: `git commit -m "Initial commit of AI News Analyzer frontend and backend"`

2.  **Create GitHub Repository:**
    *   Go to [github.com](https://github.com) and create a new repository (e.g., `ai-news-analyzer`). Choose Public or Private. **If you included your API key in `.ebextensions/01_env_vars.config`, make this repository PRIVATE.**
    *   Follow GitHub's instructions to push your existing local repository:
        ```bash
        git remote add origin YOUR_GITHUB_REPO_URL.git
        git branch -M main
        git push -u origin main
        ```
        (Replace `YOUR_GITHUB_REPO_URL.git` with the URL provided by GitHub).

3.  **Create README.md:** Create a file named `README.md` in the root `ai-news-analyzer` directory. Add the following content, filling in the details:

    ```markdown
    # AI News Analyzer

    This web application allows users to upload a news article (text or file) and receive an AI-generated summary and a list of mentioned nationalities/countries.

    ## Live URLs

    *   **Frontend:** [Your S3 Website Endpoint URL] (e.g., http://yourname-ai-news-analyzer-frontend.s3-website-us-east-1.amazonaws.com)
    *   **Backend API:** [Your Elastic Beanstalk Environment URL] (e.g., http://ai-news-analyzer-env.eba-xxxxxxxx.us-east-1.elasticbeanstalk.com)

    ## Technology Stack

    *   **Frontend:** React (using Create React App), JavaScript, CSS, Fetch API
    *   **Backend:** Python, FastAPI, Uvicorn
    *   **AI:** OpenAI API (GPT-3.5 Turbo used in example)
    *   **Cloud Hosting:**
        *   Backend: AWS Elastic Beanstalk (Python platform)
        *   Frontend: AWS S3 Static Website Hosting

    ## Project Structure

    ```
    ai-news-analyzer/
    â”œâ”€â”€ backend/             # FastAPI application
    â”‚   â”œâ”€â”€ .ebextensions/   # EB configuration files (e.g., env vars)
    â”‚   â”‚   â””â”€â”€ 01_env_vars.config
    â”‚   â”œâ”€â”€ venv/            # Python virtual environment (ignored by git)
    â”‚   â”œâ”€â”€ main.py          # FastAPI application code
    â”‚   â”œâ”€â”€ requirements.txt # Python dependencies
    â”‚   â”œâ”€â”€ Procfile         # Tells EB how to run the app
    â”‚   â””â”€â”€ .env             # Local environment variables (ignored by git)
    â”œâ”€â”€ frontend/            # React application
    â”‚   â”œâ”€â”€ node_modules/    # Node.js dependencies (ignored by git)
    â”‚   â”œâ”€â”€ public/          # Public assets for React app
    â”‚   â”œâ”€â”€ src/             # React source code (App.js, App.css, etc.)
    â”‚   â”œâ”€â”€ build/           # Production build output (ignored by git)
    â”‚   â”œâ”€â”€ package.json     # Node.js project manifest & dependencies
    â”‚   â””â”€â”€ ...
    â”œâ”€â”€ .gitignore           # Specifies intentionally untracked files
    â””â”€â”€ README.md            # This file
    ```

    ## Setup Instructions (Local Development)

    **Prerequisites:**
    *   Node.js & npm
    *   Python 3.8+ & pip
    *   Git
    *   OpenAI API Key

    **Backend:**
    1.  Navigate to the `backend` directory: `cd backend`
    2.  Create and activate a virtual environment:
        ```bash
        python -m venv venv
        # Windows: venv\Scripts\activate
        # macOS/Linux: source venv/bin/activate
        ```
    3.  Install dependencies: `pip install -r requirements.txt`
    4.  Create a `.env` file in the `backend` directory with your OpenAI key:
        ```env
        OPENAI_API_KEY=your_openai_api_key_here
        ```
    5.  Run the backend server: `uvicorn main:app --reload --port 8000`
    6.  The API will be available at `http://localhost:8000`. Access docs at `http://localhost:8000/docs`.

    **Frontend:**
    1.  Navigate to the `frontend` directory: `cd ../frontend`
    2.  Install dependencies: `npm install`
    3.  **IMPORTANT:** Update the `BACKEND_API_URL` constant in `src/App.js` to point to your backend (e.g., `http://localhost:8000/analyze` for local testing).
    4.  Run the frontend development server: `npm start`
    5.  The application will open at `http://localhost:3000`.

    ## Deployment Notes

    **Backend (AWS Elastic Beanstalk):**
    1.  Prerequisites: AWS Account, AWS CLI configured, EB CLI installed.
    2.  Navigate to the `backend` directory.
    3.  **IMPORTANT:** If your GitHub repo is PUBLIC, remove the `OPENAI_API_KEY` from `.ebextensions/01_env_vars.config` before committing/pushing. Set it manually via the AWS EB Console (Configuration > Software > Environment properties) after deployment instead. If PRIVATE, ensure the correct key is set there.
    4.  Initialize EB (if not already done): `eb init -p python-3.9 -r YOUR_REGION ai-news-analyzer-backend` (replace version/region)
    5.  Create the environment (first time): `eb create ai-news-analyzer-env`
    6.  Deploy updates: `eb deploy`
    7.  Access logs: `eb logs`
    8.  Check status: `eb status`

    **Frontend (AWS S3):**
    1.  Ensure `BACKEND_API_URL` in `frontend/src/App.js` points to the *deployed* Elastic Beanstalk URL.
    2.  Navigate to the `frontend` directory.
    3.  Build the app: `npm run build`
    4.  Create an S3 bucket configured for static website hosting (Index document: `index.html`). Remember to disable "Block all public access" and add a bucket policy to allow public `s3:GetObject`.
    5.  Upload the *contents* of the `frontend/build` directory to the root of the S3 bucket.
    6.  Access the site via the S3 bucket website endpoint URL.

    ## API Documentation

    The backend API exposes one main endpoint:

    *   **Endpoint:** `POST /analyze`
    *   **Description:** Analyzes uploaded article text (from form data) for summary and nationalities.
    *   **Request Body:** `multipart/form-data` containing EITHER:
        *   `text_content`: (string) The raw text of the article.
        *   `file_upload`: (file) An uploaded file (`.txt` or `.docx`).
    *   **Success Response (200 OK):**
        ```json
        {
          "summary": "string",
          "nationalities": ["string", ...]
        }
        ```
    *   **Error Responses:**
        *   `400 Bad Request`: Invalid input (e.g., no input, invalid file type, empty text).
        *   `413 Payload Too Large`: Input text exceeds the maximum allowed length.
        *   `429 Too Many Requests`: OpenAI Rate Limit Exceeded.
        *   `500 Internal Server Error`: Backend processing error or unhandled exception.
        *   `503 Service Unavailable`: Cannot connect to OpenAI API.

    The root endpoint `GET /` returns a welcome message: `{"message": "Welcome to the AI News Analyzer API"}`.

    ## Assumptions and Limitations

    *   Assumes UTF-8 or Latin-1 encoding for `.txt` files.
    *   Relies on OpenAI's ability to accurately summarize and extract nationalities based on the provided prompts. Prompt engineering might need refinement for better accuracy or different languages.
    *   Basic error handling is implemented. More robust validation and error handling could be added.
    *   No database storage for results or uploads (meets core requirements, bonus point).
    *   No user authentication (meets core requirements, bonus point).
    *   Frontend styling is basic using plain CSS as requested.
    *   Input text length is limited on the backend (`MAX_LENGTH` in `main.py`) to prevent abuse and control costs.
    *   CORS is enabled permissively (`allow_origins=["*"]`). For production, this should be restricted to the specific frontend URL.
    *   The `.docx` parser reads paragraph text; it might not handle complex formatting, tables, or images correctly.

    ```

---

**Phase 7: Final Steps**

1.  **Review:** Read through all the code and configuration files. Check your live URLs.
2.  **Commit Final Changes:** Add the `README.md` and any other changes to Git, commit, and push to GitHub.
    ```bash
    git add README.md
    git commit -m "Add README file and final instructions"
    git push origin main
    ```
3.  **Provide Deliverables:** Share your GitHub repository link and the live URLs for the frontend and backend.

---

This is a comprehensive guide, but building and deploying applications always involves potential troubleshooting. Use the logging features (`eb logs`, browser developer console), check AWS console statuses, and carefully read any error messages. Good luck!
--- End File: googleAI.txt ---

--- File: .gitignore ---
# General
.DS_Store
*.log
*.pot
*.pyc
__pycache__/

# Python Virtual Environment
backend/venv/
backend/.env

# Node Modules
frontend/node_modules/
frontend/build/
frontend/.env*
frontend/npm-debug.log*
frontend/yarn-debug.log*
frontend/yarn-error.log*

# AWS Elastic Beanstalk
.elasticbeanstalk/
--- End File: .gitignore ---

--- File: logs.txt ---
(htx_torch) (base) spiraldestroyer@DESKTOP:~/ai_webapp/repo/news-analyzer/backend$ eb deploy
Creating application version archive "app-250430_235548618205".
Uploading ai-news-analyzer-backend/app-250430_235548618205.zip to S3. This may take a while.
Upload Complete.
2025-04-30 15:55:53    INFO    Environment update is starting.      
2025-04-30 15:55:57    INFO    Deploying new version to instance(s).
2025-04-30 15:56:01    INFO    Instance deployment used the commands in your 'Procfile' to initiate startup of your application.
2025-04-30 15:56:07    INFO    Instance deployment completed successfully.
2025-04-30 15:56:14    INFO    New application version was deployed to running EC2 instances.
2025-04-30 15:56:14    INFO    Environment update completed successfully.
                                                                      
(htx_torch) (base) spiraldestroyer@DESKTOP:~/ai_webapp/repo/news-analyzer/backend$ eb status
Environment details for: ai-news-analyzer-env
  Application name: ai-news-analyzer-backend
  Region: us-east-1
  Deployed Version: app-250430_235548618205
  Environment ID: e-w68dbwrwb2
  Platform: arn:aws:elasticbeanstalk:us-east-1::platform/Python 3.9 running on 64bit Amazon Linux 2023/4.5.1
  Tier: WebServer-Standard-1.0
  CNAME: ai-news-analyzer-env.eba-ny77vj8c.us-east-1.elasticbeanstalk.com
  Updated: 2025-04-30 15:56:14.715000+00:00
  Status: Ready
  Health: Green
(htx_torch) (base) spiraldestroyer@DESKTOP:~/ai_webapp/repo/
(htx_torch) (base) spiraldestroyer@DESKTOP:~/ai_webapp/repo/news-analyzer/backe
(htx_torch) (base) spiraldestroyer@DESKTOP:~/ai_webapp/repo/
(htx_torch) (base) spiraldestroyer@DESKTOP:~/ai_webapp/repo/news-analyzer/backe
(htx_torch) (base) spiraldestroyer@DESKTOP:~/ai_webapp/repo/news-analyzer/backend$ 



--- End File: logs.txt ---

--- File: test.txt ---
A Korean Foundation with International Roots

The K-pop industry began its global expansion in the early 2000s, spearheaded by groups like TVXQ, BoA, and BigBang, all consisting of South Korean nationals. However, by the 2010s, entertainment agencies such as SM Entertainment, JYP, and HYBE (formerly BigHit) began recruiting talent from abroad, recognizing the need to diversify for a broader international appeal.

Todayâ€™s top K-pop groups are often multinational. For example:

    TWICE, formed by JYP Entertainment, consists of members from South Korea (Nayeon, Dahyun, Jihyo, Chaeyoung, Jeongyeon), Japan (Momo, Sana, Mina), and Taiwan (Tzuyu).

    BLACKSWAN, a lesser-known but notable group, included a Senegalese-Belgian member named Fatou, making her the first Black K-pop idol in a major group.

    NCT, under SM Entertainment, is particularly known for its international structure. Its sub-units include members from South Korea, China, Japan, Thailand, Canada, and the United States.

These groups perform songs in Korean but frequently incorporate English, Japanese, Chinese, and other languages, reflecting the backgrounds of their members and their target global audience.
Fans Without Borders

The K-pop fandom is as diverse as the groups themselves. According to a 2023 survey by the Korean Foundation for International Cultural Exchange, the largest K-pop fanbases by country include:

    Philippines

    Indonesia

    United States

    Brazil

    Mexico

K-pop concerts routinely sell out across Europe, South America, and the Middle East. Fan-made subtitles, social media campaigns, and streaming collectivesâ€”often organized by fans from Germany, India, Nigeria, and Argentinaâ€”demonstrate the truly borderless nature of K-pop enthusiasm.
Bridging Cultures

Perhaps most significant is how K-pop fosters intercultural exchange. Young fans in France are learning Korean; aspiring singers in Vietnam are training in Seoul; and idols from Australia, like Felix and Bang Chan of Stray Kids, are becoming role models for global youth.

This blend of nationalities has not only reshaped what it means to be a K-pop artist but also redefined how music can be a platform for global cultural connection.
--- End File: test.txt ---

--- File: repo/news-analyzer/backend/.env ---
OPENAI_API_KEY='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'
--- End File: repo/news-analyzer/backend/.env ---

--- File: repo/news-analyzer/backend/.gitignore ---

# Elastic Beanstalk Files
.elasticbeanstalk/*
!.elasticbeanstalk/*.cfg.yml
!.elasticbeanstalk/*.global.yml

--- End File: repo/news-analyzer/backend/.gitignore ---

--- File: repo/news-analyzer/backend/main.py ---
# backend/main.py
import os
import io
# ADD 'Any' HERE
from typing import Optional, Any
# --- Keep other imports ---
from dotenv import load_dotenv
from fastapi import FastAPI, File, UploadFile, Form, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
# from pydantic import BaseModel # Not strictly needed here
import openai
import docx

# --- Keep load_dotenv() and Configuration ---
load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    print("Error: OPENAI_API_KEY not found in environment variables.")
if OPENAI_API_KEY:
     openai.api_key = OPENAI_API_KEY
else:
    print("Warning: OpenAI API Key not configured. API calls will fail.")

# --- Keep FastAPI App Initialization and CORS Middleware ---
app = FastAPI(title="AI News Analyzer API")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Keep Helper Functions (get_openai_completion, summarize_text, extract_nationalities, read_docx) ---
# ... (ensure these are still present and correct) ...
def get_openai_completion(prompt_text, model="gpt-3.5-turbo"):
    """Calls the OpenAI Chat Completion API."""
    if not OPENAI_API_KEY:
         raise HTTPException(status_code=500, detail="OpenAI API key not configured on the server.")
    try:
        response = openai.chat.completions.create(
            model=model,
            messages=[
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": prompt_text}
            ]
        )
        if response.choices and len(response.choices) > 0:
            message_content = response.choices[0].message.content
            if message_content:
                return message_content.strip()
        print("Warning: Could not extract content from OpenAI response structure:", response)
        # Handle cases where the response might be valid but empty or unexpected
        if response.choices and len(response.choices) > 0 and response.choices[0].message is None:
             return "OpenAI returned an empty message."
        return "Error: Could not extract content from OpenAI response."

    except openai.APIError as e:
         print(f"OpenAI API returned an API Error: {e}")
         raise HTTPException(status_code=500, detail=f"OpenAI API Error: {e}")
    except openai.APIConnectionError as e:
        print(f"Failed to connect to OpenAI API: {e}")
        raise HTTPException(status_code=503, detail=f"OpenAI Connection Error: {e}")
    except openai.RateLimitError as e:
        print(f"OpenAI API request exceeded rate limit: {e}")
        raise HTTPException(status_code=429, detail=f"OpenAI Rate Limit Exceeded: {e}")
    except Exception as e:
        print(f"An unexpected error occurred during OpenAI call: {e}")
        import traceback
        traceback.print_exc() # Print stack trace for debugging
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")

def summarize_text(text):
    """Generates a summary using OpenAI."""
    prompt = f"""
    Please summarize the following news article in 2-4 concise sentences:

    \"\"\"
    {text}
    \"\"\"

    Summary:
    """
    return get_openai_completion(prompt)

def extract_nationalities(text):
    """Extracts nationalities/countries using OpenAI."""
    prompt = f"""
    Analyze the following news article and list all mentioned nationalities, countries, or peoples.
    If a country is mentioned (e.g., France, Japan), list the country name.
    If a nationality or people is mentioned (e.g., French, Japanese, Canadians), list the nationality/people.
    Provide the output as a comma-separated list. If none are found, respond with "None".

    Article:
    \"\"\"
    {text}
    \"\"\"

    Nationalities/Countries mentioned (comma-separated):
    """
    result = get_openai_completion(prompt)
    # Added more robust check for non-error, non-"None" results
    if result and isinstance(result, str) and not result.startswith("Error:") and not result.startswith("OpenAI returned") and result.lower().strip() != "none":
        return [item.strip() for item in result.split(',') if item.strip()]
    else:
        if result and (result.startswith("Error:") or result.startswith("OpenAI returned")):
             print(f"Warning/Error extracting nationalities: {result}") # Log the specific error
        return [] # Return empty list on "None" or error

def read_docx(file_content: bytes) -> str:
    """Reads text content from a .docx file's bytes."""
    try:
        doc_stream = io.BytesIO(file_content)
        doc = docx.Document(doc_stream)
        full_text = []
        for para in doc.paragraphs:
            full_text.append(para.text)
        return '\n'.join(full_text)
    except Exception as e:
        print(f"Error reading docx file: {e}")
        raise HTTPException(status_code=400, detail=f"Could not read the .docx file. Error: {e}")

# --- API Endpoints ---
@app.get("/")
async def root():
    return {"message": "Welcome to the AI News Analyzer API"}

@app.post("/analyze")
async def analyze_article(
    text_content: Optional[str] = Form(None),
    # CHANGE THIS LINE: Use Optional[Any]
    file_upload: Optional[Any] = File(None)
):
    """
    Analyzes news article text (either provided directly or via file upload)
    to generate a summary and extract nationalities.
    Accepts either 'text_content' (string) or 'file_upload' (.txt or .docx).
    """
    article_text = ""
    filename = None

    # --- Input Validation and Reading ---
    # ADD isinstance check here
    if file_upload and isinstance(file_upload, UploadFile):
        # Only proceed if file_upload is NOT None AND is actually an UploadFile object
        if not file_upload.filename:
             # Handle case where UploadFile object exists but has no filename (should be rare)
             raise HTTPException(status_code=400, detail="Uploaded file is missing a filename.")

        filename = file_upload.filename
        print(f"Received file: {filename}")
        contents = await file_upload.read()
        # Check if file content is empty AFTER reading
        if not contents:
             raise HTTPException(status_code=400, detail=f"Uploaded file '{filename}' appears to be empty.")

        # --- File type processing remains the same ---
        if filename.lower().endswith(".txt"):
            try:
                article_text = contents.decode("utf-8")
            except UnicodeDecodeError:
                try:
                     article_text = contents.decode("latin-1")
                except Exception as e:
                    raise HTTPException(status_code=400, detail=f"Could not decode .txt file '{filename}'. Ensure it's UTF-8 or Latin-1 encoded. Error: {e}")
        elif filename.lower().endswith(".docx"):
             try:
                article_text = read_docx(contents)
             except HTTPException as e:
                 # Add filename to the error detail if possible
                 e.detail = f"Error processing file '{filename}': {e.detail}"
                 raise e
             except Exception as e:
                print(f"Unexpected error reading .docx '{filename}': {e}")
                raise HTTPException(status_code=500, detail=f"Server error processing .docx file '{filename}': {e}")
        else:
            raise HTTPException(status_code=400, detail=f"Invalid file type for '{filename}'. Please upload a .txt or .docx file.")

    elif text_content:
        print("Received text content.")
        article_text = text_content
    else:
        # This condition is reached if text_content is None/empty AND
        # file_upload was None or not an UploadFile instance (e.g., the empty string '')
        raise HTTPException(status_code=400, detail="No input provided. Please provide text_content or upload a valid file.")

    # Check for empty text *after* potentially reading from file or getting text_content
    if not article_text.strip():
         input_source = f"file '{filename}'" if filename else "text_content"
         raise HTTPException(status_code=400, detail=f"Input {input_source} is empty.")

    MAX_LENGTH = 15000
    if len(article_text) > MAX_LENGTH:
         raise HTTPException(status_code=413,
                             detail=f"Input text is too long ({len(article_text)} > {MAX_LENGTH} chars). Please provide shorter text.")

    # --- Processing ---
    print("Input text length:", len(article_text))
    print("Calling OpenAI for summary...")
    summary = summarize_text(article_text)
    print("Calling OpenAI for nationalities...")
    nationalities = extract_nationalities(article_text)
    print("Analysis complete.")

    # --- Return Response ---
    return {
        "filename": filename, # Will be None if text_content was used
        "summary": summary,
        "nationalities": nationalities
    }


# --- Keep Exception Handlers ---
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail},
    )

@app.exception_handler(Exception)
async def generic_exception_handler(request: Request, exc: Exception):
    print(f"An unexpected error occurred: {exc}")
    import traceback
    traceback.print_exc()
    return JSONResponse(
        status_code=500,
        content={"detail": "An internal server error occurred."},
    )


# --- Keep local running block ---
if __name__ == "__main__":
    import uvicorn
    # Ensure reload=True works well by using string format "main:app"
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
--- End File: repo/news-analyzer/backend/main.py ---

--- File: repo/news-analyzer/backend/requirements.txt ---
annotated-types==0.7.0
anyio==4.9.0
certifi==2025.4.26
click==8.1.8
distro==1.9.0
fastapi==0.115.12
h11==0.16.0
httpcore==1.0.9
httptools==0.6.4
httpx==0.28.1
idna==3.10
jiter==0.9.0
lxml==5.4.0
openai==1.76.2
pydantic==2.11.4
pydantic_core==2.33.2
python-docx==1.1.2
python-dotenv==1.1.0
python-multipart==0.0.20
PyYAML==6.0.2
sniffio==1.3.1
starlette==0.46.2
tqdm==4.67.1
typing-inspection==0.4.0
typing_extensions==4.13.2
uvicorn==0.34.2
uvloop==0.21.0
watchfiles==1.0.5
websockets==15.0.1

--- End File: repo/news-analyzer/backend/requirements.txt ---

--- File: repo/news-analyzer/backend/.elasticbeanstalk/config.yml ---
branch-defaults:
  default:
    environment: ai-news-analyzer-env
    group_suffix: null
global:
  application_name: ai-news-analyzer-backend
  branch: null
  default_ec2_keyname: null
  default_platform: Python 3.9
  default_region: us-east-1
  include_git_submodules: true
  instance_profile: null
  platform_name: null
  platform_version: null
  profile: eb-cli
  repository: null
  sc: null
  workspace_type: Application

--- End File: repo/news-analyzer/backend/.elasticbeanstalk/config.yml ---

--- File: repo/aws/README.md ---
# AWS CLI v2

This bundle contains a built executable of the AWS CLI v2.

## Installation

To install the AWS CLI v2, run the `install` script:
```
$ sudo ./install 
You can now run: /usr/local/bin/aws --version
```
This will install the AWS CLI v2 at `/usr/local/bin/aws`.  Assuming
`/usr/local/bin` is on your `PATH`, you can now run:
```
$ aws --version
```


### Installing without sudo

If you don't have ``sudo`` permissions or want to install the AWS
CLI v2 only for the current user, run the `install` script with the `-b`
and `-i` options:
```
$ ./install -i ~/.local/aws-cli -b ~/.local/bin
``` 
This will install the AWS CLI v2 in `~/.local/aws-cli` and create
symlinks for `aws` and `aws_completer` in `~/.local/bin`. For more
information about these options, run the `install` script with `-h`:
```
$ ./install -h
```

### Updating

If you run the `install` script and there is a previously installed version
of the AWS CLI v2, the script will error out. To update to the version included
in this bundle, run the `install` script with `--update`:
```
$ sudo ./install --update
```


### Removing the installation

To remove the AWS CLI v2, delete the its installation and symlinks:
```
$ sudo rm -rf /usr/local/aws-cli
$ sudo rm /usr/local/bin/aws
$ sudo rm /usr/local/bin/aws_completer
```
Note if you installed the AWS CLI v2 using the `-b` or `-i` options, you will
need to remove the installation and the symlinks in the directories you
specified.

--- End File: repo/aws/README.md ---
